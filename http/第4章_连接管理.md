# 第4章 连接管理

目录
[TOC]

## 读书笔记

## 4.1 TCP连接

**TCP/IP**是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集

### 4.1.1 TCP的可靠数据管道
TCP为HTTP提供一条可靠的**比特**传输管道

TCP会按序、无差错地承载HTTP数据

Web浏览器通过TCP连接与Web服务器进行交互的过程：
* 服务器通过URL得到：
1. 浏览器解析主机名
2. 浏览器查询主机名的IP地址(DNS)
3. 浏览器获得端口号(80)

* 建立到Web服务器的TCP连接
4. 浏览器发起到IP地址+端口的连接

* 通过这条TCP连接进行发送请求报文，读取响应报文和关闭连接
5. 浏览器向服务器发送一条HTTP请求报文
6. 浏览器从服务器读取HTTP响应报文
7. 浏览器关闭连接

### 4.1.2 TCP流是分段的、由IP分组传送
TCP的数据是通过名为IP分组(或IP数据报)的小数据块发送的

HTTP网络协议栈
* HTTP - 应用层
* TCP - 传输层
* IP - 网络层
* 网络接口层 - 数据链路层

HTTPS网络协议栈
* HTTP - 应用层
* TSL or SSL - 安全层
* TCP - 传输层
* IP - 网络层
* 网络接口层 - 数据链路层

HTTP传送报文时，以流的形式将报文数据的内容通过一条打开的额TCP连接按需传输，TCP收到数据流之后，会将数据流砍成被称为段的小数据块，并将段封装在IP分组中，通过因特网进行传输

每一个TCP段都是由IP分组承载，从一个IP地址发送到另外一个IP地址

每一个IP地址分组包含：一个IP分组首部(通常为20字节)、一个TCP段首部(通常为20字节)和一个TCP数据块(0或多个字节)

IP首部包含了源和目的IP地址、长度和其他一些标记

TCP首部包含了TCP端口号、TCP控制标记以及用户数据排序和完整性检查的一些数字值

### 4.1.3 保持TCP连接的正确运行
源IP地址、源端口号、目的IP地址、目的端口号四个值能定义一条TCP连接

TCP通过端口号来保持所有连接的正确运行

### 4.1.4 用TCP套接字编程
**套接字API**允许用户创建TCP的端点数据结构，将端点与远程服务器的TCP端点进行连接，并对数据流进行读写

| 套接字API调用                | 描述                                         |
| ---------------------------- | -------------------------------------------- |
| s = socket(<parameters)      | 创建一个新的、未命名、未关联的套接字         |
| bind(s, <local IP:port>)     | 向套接字赋一个本地端口号和接口               |
| connect(s, <remote IP:port>) | 创建一条连接本地套接字与远程主机及端口的连接 |
| listen(s, ...)               | 标识一个本地套接字，使其可以合法接受连接     |
| s2 = accept(s)               | 等待某人一条到本地端口的连接                 |
| n = read(s, buffer, n)       | 尝试从套接字向缓冲区读取n个字节              |
| n = write(s, buffer, n)      | 尝试从缓冲区向套接字写入n个字节              |
| close(s)                     | 完全关闭TCP连接                              |
| shutdown(s, <side>)          | 只关闭TCP连接的输入或输出端                  |
| getsocket(s, ...)            | 读取某个内部套接字配置选项的值               |
| setsocket(s, ...)            | 修改某个内部套接字配置选项的值               |

TCP客户端与服务器通过TCP套接字接口进行通信的过程

| 客户端                         | 服务器                           |
| ------------------------------ | -------------------------------- |
|                                | 创建新的套接字（socket）         |
|                                | 将套接字绑定在端口80上去（bind） |
|                                | 允许套接字进行连接（listen）     |
|                                | 等待连接（accept）               |
| 获取IP地址和端口号             |                                  |
| 创建新的套接字（socket）       |                                  |
| 连接到服务器IP:port（connect） |                                  |
|                                | 通知应用程序有连接到来           |
| 连接成功                       | 开始读取请求（read）             |
| 发送HTTP请求（write）          |                                  |
| 等到HTTP响应（read）           | 处理HTTP请求报文                 |
|                                | 回送HTTP响应（write）            |
| 处理HTTP响应                   | 关闭连接（close）                |
| 关闭连接（close）              |                                  |

建立连接的时间长短取决于服务器距离的远近、服务器的负载情况以及因特网的拥挤程度

## 4.2 对TCP性能的考虑
所有HTTP事务的性能在很大程度上取决于底层TCP通道的性能

### 4.2.1 HTTP事务的延时
除非客户端或服务器超载，或处理复杂的动态资源，否则HTTP时延就是由TCP网络延时构成的

HTTP事务延时的几个主要原因：
1. 确定Web服务器的IP地址和端口号 - 通过DNS解析系统将URI中的主机名转换成一个IP地址可能花费数十秒的时间(最近没曾访问)
2. 客户端想服务器发送一条TCP连接请求并等待服务器回送一个请求接受应答 - 每条新的TCP连接都会有连接建立时延，一般两秒，会随HTTP事务的数量快速叠加上去
3. 连接建立后，客户端通过新建立的TCP管道发送HTTP请求，Web服务器从TCP连接中读取请求报文并对请求进行处理 - 因特网传输请求报文，以及服务器处理请求报文都需要时间
4. Web服务器会回送HTTP响应

TCP网络延时的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离

### 4.2.2 性能聚焦区域
最常见的TCP相关时延：
1. TCP连接建立握手
2. TCP慢启动拥塞控制
3. 数据聚集的Nagle算法
4. 用于捎带确认的TCP确认算法
5. TIME_WAIT时延和端口耗尽

### 4.2.3 TCP连接的握手时延
TCP连接握手的步骤：
1. 请求新的TCP连接时，客户端向服务器发送一个小的TCP分组(SYN标记，连接请求)
2. 服务器接受连接后，会对连接参数进行计算，回送客户端一个TCP分组(SYN标记+ACK标记，连接请求已被接受)
3. 客户端向服务器回送一条确认信息，通知连接已成功建立(现代TCP栈允许在确认分组发送数据)

TCP分组对HTTP程序员是不可见的，都由TCP/IP软件管理，HTTP程序员只能看到创建TCP连接时存在的时延

### 4.2.4 延迟确认
因特网路由器超负荷会随意丢弃分组，则其无法确保可靠的分组传输

TCP确保数据成功传输的确认机制：
每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组
如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据
由于确认报文很小，TCP允许在发往相同方向的输出数据分组中对其进行捎带

**延迟算法**在一个特定的窗口时间(通常在100~200毫秒)内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组；若没有输出数据分组，则将确认信息放在单独的分组中传送

HTTP具有双峰特征的请求，应答行为降低了捎带信息的可能
- **双峰特征**是HTTP的请求和应答两个传输数据高峰
- 触发TCP中nagle算法导致延时(HTTP报文没有那么大的数据量的时候，即无法填满一个分组，可能会因为等待那些不会永远到来的数据而产生延时)，故可以调整或禁止延迟确认算法

### 4.2.5 TCP慢启动
TCP数据传输的性能还取决于TCP连接的使用期

**TCP慢启动** - TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，若数据成功传输，会随着时间推移提高传输速度；**目的防止因特网的突然过载和拥塞**

TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数

每成功接收一个分组，发送端就有了发送两个分组的权限

**打开拥塞窗口** - 某个HTTP事务有大量数据发送，是不能一次将所有分组都发送出去；必须先发送一个分组，等待确认，然后又可以发送两个分组，两个分组都等待确认，然后又可以发送四个分组，以此类推

### 4.2.6 Nagle算法与TCP_NODELAY
**Nagle算法**在发送一个分组之前，将大量TCP数据(针对大量包含少量数据的分组)绑定在一起，以提高网络效率

Nagle算法会引发HTTP性能问题：
1. 小的HTTP报文可能无法填满一个分组，可能因为等待那些永远不会到来的额外数据而产生时延
2. Nagle算法与延迟确认存在交互问题 - Nagle算法会阻止数据发送，直到确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100~200毫秒

HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY，禁用Nagle算法，提高性能

### 4.2.7 TIME_WAIT累积与端口耗尽
当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号；通常维持所估计的最大分段使用期的两倍(称为2MSL，通常2分钟)以确保在这段时间内不会创建具有相同地址和端口号的新连接

服务器通常在HTTP的默认TCP端口80上进行监听，用TIME_WAIT防止端口号重用时，也限制了连接到服务器的客户端IP地址数和可用的连接值组合

**TIME_WAIT端口耗尽** - 客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性；但由于可用源端口的数量有限，而且在2MSL内连接是无法重用的

解决TIME_WAIT端口耗尽的问题：
- 增加客户端负载生成机器的数量
- 或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合

## 4.3 HTTP连接的处理
### 4.3.1 常被误解的Connection首部
HTTP允许在客户端和最终的源端服务器之间存在一串HTTP中间实体(代理、高速缓存等)

HTTP的Connection首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项
*e.g.* Connection: close 说明发送完下一条报文之后必须关闭连接

Connection首部可以承载3中不同类型的标签：
- HTTP首部字段名，列出了只与此连接有关的首部
- 任意标签值，用于描述此连接的非标准选项
- 值close，说明操作完成之后需关闭这条持久连接

连接标签中包含了一个HTTP首部字段的名称，这个首部字段则包含了一些与连接有关的信息，不能将其转发出去

在将报文转发出去之前，必须删除Connection首部列出的所有首部字段
> 代理服务器和后端服务器做的是短链接交互，客户端和代理服务器做的是长连接交互，当然最重要的一点是客户端不直接和真正的后端建立连接，这个是整个问题的关键。
> 由于效率方面考虑，代理服务器默认不和后端服务器建立长连接，但并不代表不能建立长连接，拿nginx的反向代理的配置来说，默认是走的http 1.0协议，也可以通过配置走http 1.1协议，这个时候nginx和后端服务之间就是有keep-alive的。
> 长连接可以做到复用，减轻频繁的连接握手操作；缺点是连接是复用的，请求有波峰的时候，由于若干请求数据转发是在一条连接上的，资源利用的并不充分，后端服务也要有事务维护成本

### 4.3.2 串行事务处理时延
串行加载引入的缺点：
1. 存在时延 - 每个事务都需要建立新的连接，连接时延和慢启动时延会叠加
2. 加载资源的时候，页面没动静，用户对装载进度一无所知
3. 浏览器在对象加载完毕之前无法获知对象的尺寸

提高HTTP的连接性能的技术
- 并行连接 - 通过多条TCP连接发起的HTTP请求
- 持久链接 - 重用TCP连接，消除连接及关闭时延
- 管道化连接 - 通过共享的TCP连接发起的HTTP请求
- 复用的连接 - 交替传送请求和响应报文(实验阶段)

## 4.4 并行连接
HTTP允许客户端打开多条连接，并行地执行多个HTTP事务

### 4.4.1 并行连接可能会提高页面的加载速度
包含嵌入对象的组合页面能通过并行连接克服单跳连接的空载时间和带宽限制，连接的时延将会是重叠的，加载速度也会有所提高

### 4.4.2 并行连接不一定更快
客户端的网络带宽不足时，大部分时间可能都用来传输数据，这个情况下，一个连接到速度较快的服务器上的HTTP事务会很容易地耗尽所有可能的Modern带宽，每个对象都会以较慢的速度按比例加载，这样性能提升就很小，甚至没有

浏览器确实使用了并行连接，但它们将并行连接的总数限制为一个较小的值(通常为4个)；服务器可以随意关闭来自特定客户端的超量连接

### 4.4.3 并行连接可能让人感觉更快一些
实际上，多条连接会产生一些额外的开销，使用并行连接装载整个页面所需的时间很可能比串行下载的时间更长

## 4.5 持久链接
**站点本地性** - 初始化了对某服务器HTTP请求的应用程序很可能在不久的将来对那台服务器发起更多的请求

HTTP/1.1允许HTTP设备在事务处理结束之后将TCP连接保持打开状态，以便为未来的HTTP请求重用现存的连接

**持久连接** - 在事务处理结束之后仍然保持在打开状态的TCP连接，直到客户端或服务器决定将其关闭为止

**非持久链接** - 在每个事务处理结束之后关闭

重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段

已经打开的连接还可以避开慢启动的拥塞适应阶段，以便更快地进行数据的传输

### 4.5.1 持久以及并行连接
并行连接的缺点：
- 每个事务都打开/关闭一条新的连接，会耗费时间和带宽
- 由于TCP慢启动特性的存在，每条新连接的性能会有所降低
- 可以打开的并行连接数量实际是有限的

持久连接的优点：
- 降低了时延和连接建立的开销，将连接保持在已调谐状态
- 减少打开连接的潜在数量

持久连接与并行连接配合使用可能是最高效的方式，很多Web应用程序都会打开少量的并行连接，其中每个都是持久连接

持久连接的两种类型：
- HTTP/1.0+ keep-alive连接
- HTTP/1.1 presistent连接

### 4.5.2 HTTP/1.0+ keep-alive连接
由于去除了进行连接(慢启动阶段)和关闭连接的开销，所以耗时上有所缩减

### 4.5.3 Keep-Alive操作
keep-alive已经不再使用，而且HTTP/1.1规范中没有对它的说明，但浏览器和服务器对keep-alive握手的使用仍然相当广泛

HTTP/1.0 keep-alive事务首部的握手过程

- 实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection: Keep-Alive首部请求将一条连接保持打开状态
- 若服务器愿意为下一条请求将连接保持在打开状态，就会在响应中包含相同的首部
- 否则，响应中没有Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接

### 4.5.4 Keep-Alive选项
keep-alive首部是**请求将连接保持在活跃状态**

发出keep-alive请求之后，客户端和服务器并不一定同意进行keep-alive会话，可以任意时刻关闭空闲的keep-alive连接，也可以随意限制keep-alive连接所处理事务的数量

keep-alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为：
1. timeout - keep-alive响应首部发送的，估计了服务器希望将连接保持在活跃状态的时间
2. max - keep-alive响应首部发送的，估计了服务器希望能把多少个事务事务保持此连接的活跃状态
3. name [=value] - 未经处理的属性，用于诊断和调试

### 4.5.5 Keep-Alive连接的限制和规则
- 在HTTP/1.0中，keep-alive并不是默认使用的。**客户端必须发送一个Connection: Keep-Alive请求首部来激活keep-alive连接**
- Connection: Keep-Alive首部必须随所有希望保持持久连接的报文一起发送；否则在**没有发送(Connection: Keep-Alive首部)的那条请求之后关闭连接**
- 客户端探明响应中没有Connection: Keep-Alive响应首部，就知道服务器发送响应之后是否关闭连接了
- 实体的主体部分必须有正确的Content-Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码,否则事务处理的另外一端无法精确地检出一条报文的结束和另外一条报文的开始
- 代理和网关必须执行Connection首部规则：**代理或网关必须在将报文转发出去或将其高速缓存之前，删除在Connection首部中命中的所有首部字段以及Connection首部自身**
- 不应该与无法确认是否支持Connection首部的代理服务器建立keep-alive连接，以防止出现哑代理问题
- 从技术上讲，应该忽略所有来自HTTP/1.0设备的Connection首部字段(包括Connection: Keep-Alive),因为是可能由比较老的代理服务器误转发的
- 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备

### 4.5.6 Keep-Alive和哑代理
Web客户端的Connection: Keep-Alive首部应该只会对那条离开客户端的TCP链路产生影响

#### Connection首部和盲中继
**盲中继**是指很多老的或者简单的代理将从一个连接转发到另外一个连接中去，不对Connection首部进行特殊处理

keep-alive无法与不支持Connection首部的代理进行互操作：
1. Web客户端向代理发送了一条报文，其中包含了Connection:Keep-Alive首部，可以的话请求建立一条keep-alive连接，客户端等待响应，以确定对方是否认可它对keep-alive信道的请求
2. 哑代理收到这条HTTP请求，但它不理解Connection首部(当做一个扩展首部对待)，沿着转发链路将报文一字不漏地发送给服务器(Connection是个逐跳首部，只适合单条传输链路，不应该沿着传输链路向下传输)
3. 当Web服务器接收到经过代理转发的Connection:Keep-Alive首部时，会误以为代理(当作其他客户端一样)希望进行keep-alive对话，然后回送一个Connection:Keep-Alive响应首部
4. 哑代理将服务器的响应报文回送给客户端，并将来自Web服务器的Connection:Keep-Alive首部一起传送过去，客户端看到这个首部就会认为代理同意进行keep-alive对话
5. 客户端和服务器都认为在进行keep-alive对话，但是与它们对话的代理却对keep-alive一无所知；代理就会将受到的所有数据回送给客户端，然后等待源端服务器关闭连接，但是源端服务器认为代理已经显式地请求它将连接保持在打开状态，所以不会关闭连接，即代理挂起
6. 客户端收到回送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另外一条请求；但是代理不认为同一条连接上会有其他请求到来，则忽略请求，浏览器在转圈，不再有任何进展
7. 最后这种错误的通信会使浏览器一直挂起，直到客户端或服务器将连接超时后关闭连接

#### 代理和逐跳首部
为避免哑代理的问题发生，现代的代理都绝不转发Connection首部和所有名字出现在Connection值中的首部
*e.g.* Proxy-Authenticate、Proxy-Connection、Transfer-Encoding和Upgrade

### 4.5.7 插入Proxy-Connection
Netscape浏览器提出针对盲中继的变通办法：浏览器向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，它将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部(前提：**在客户端和服务器之间只有一个代理时**可以用这种方案来解决，多层代理依旧无法解决哑代理的问题)

### 4.5.8 HTTP/1.1持久连接
**持久连接**(presistent connection)的目的与keep-alive连接的目的相同，但工作机制更优

与HTTP/1.0+的keep-alive连接不同，HTTP/1.1持久连接在默认情况下激活的

HTTP/1.1应用程序必须向报文中显示地添加一个Connection：close首部，在事务处理结束之后将连接关闭

客户端和服务器仍然可以随时关闭空闲的连接，不发送Connection：close并不意味着服务器永远将连接保持在打开状态

### 4.5.9 持久连接的限制和规则
- 发送了Connection：close请求首部之后，客户端就无法在那条连接上发送更多的请求
- 实体主体部分的长度和相应的Content-Length一致或者用分块传输编码方式编码的连接才能持久保持
- HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接，每个持久连接都只适用于一级传输
- 由于较老的代理都会转发Connection首部，所以HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接
- 尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求
- HTTP/1.1应用程序必须能够从异步的关闭中恢复出来
- 一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载

## 4.6 管道化连接
HTTP/1.1 允许在持久连接上可选地使用请求管道

**管道连接** - 当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送；在高时延网络条件下，可以降低网络的环回时间，提供性能；在keep-alive连接上的进一步性能优化

管道连接的限制：
- HTTP客户端无法确认连接是持久的，就不应该使用管道
- 必须按照与请求相同的顺序回送HTTP响应，否则无法与其匹配起来
- HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求
- HTTP客户端不应该用管道化的方式发送会产生副作用的请求(如POST)；出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的那些，存在某些方法永远不被执行

## 4.7 关闭连接的奥秘
### 4.7.1 任意解除连接
所有HTTP客户端、服务器或代理都可以任意时刻关闭一条TCP传输连接，通常在一条报文结束时关闭连接

服务器永远都无法确定在它关闭空闲连接的那一刻，在线路那一头的客户端有没有数据要发送；如果有，那么客户端会在写入半截请求报文时发现出现了连接错误

### 4.7.2 Content-Length及截尾操作
每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主体的尺寸

一些老的HTTP服务器会省略Content-Length首部，或者包含错误的长度指示；客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的试题长度与Content-Length并不匹配，接收端应该质疑长度的正确性

接收端是缓存代理的话，代理应该将有问题的报文原封不动地转发出去以维护语义的透明性

### 4.7.3 连接关闭容限、重试以及幂等性
HTTP应用程序要做好正确处理非预期关闭的准备：
1. 客户端再执行事务时，传输连接关闭 - 客户端重新打开连接，重试
2. 客户端将大量请求放入队列中排队，但源端服务器可以关闭连接，会留下大量未处理的请求 - 重新调度

**幂等的事务**指的是不管执行一次还是多次，该事务得到结果都是相同的(GET/HEAD/PUT/DELETE/TRACE/OPTIONS方法)

**非幂的事务**则指每次执行，事务得到不确定的结果(POST方法)

客户端不应该使用管道化方式传送非幂等请求，否则传输连接过早终止会造成一些不确定的后果；非幂等请求的发送需要等待来自前一条请求的响应状态

### 4.7.4 正常关闭连接
TCP连接是双向的；TCP连接的每一端都有一个输入列和一个输出列，用于数据的读或写

#### 完全关闭与半关闭
**完全关闭** - 套接字调用close()会将TCP连接的输入和输出信道都关闭了

**半关闭** - 套接字调用shutdown()单独关闭输入或输出信道

#### TCP关闭及重置错误
简单的HTTP应用程序可以只使用完全关闭

若应用程序与很多其他类型的HTTP客户端、服务器和代理进行对话且开始使用管道化持久连接时，**使用半关闭来防止对等实体收到非预期的写入错误**

关闭连接的输出信道总是很安全，连接另外一端的对等实体会从缓冲区中读出所有数据之后收到流结束的通知

关闭连接的输入信道比较危险，一旦另外一端向已关闭的输入信道发送数据，操作系统就会向另一端机器回送一条TCP连接被对端重置的报文；结果就是大部分操作系统会把这种情况当做严重的错误来处理，删除对端还未读取的所有缓存数据

#### 正常关闭
实现正常关闭的应用程序首先关闭它们的输出信道，然后等到连接另一端的对等试题关闭它的输出信道；当两端都告诉对方不在发送任何数据(比如关闭输出信道)之后，连接就会被完全关闭，而不存在重置的危险

由于无法确保对等实体会实现半关闭，或对其进行检查，需要周期性检查其输入信道的状态(查找数据，或流的末尾);在一定时间的区间内对端没有关闭输入信道，应用程序可以强制关闭连接，节省资源

### 4.8.2 HTTP性能问题 - 略
### 4.8.3 TCP/IP - 略